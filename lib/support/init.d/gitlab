#! /bin/sh

# GITLAB
# Maintainer: @randx
# Authors: rovanion.luckey@gmail.com, @randx

### BEGIN INIT INFO
# Provides:          gitlab
# Required-Start:    $local_fs $remote_fs $network $syslog redis-server
# Required-Stop:     $local_fs $remote_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: GitLab git repository management
# Description:       GitLab git repository management
# chkconfig: - 85 14
### END INIT INFO


###
# DO NOT EDIT THIS FILE!
# This file will be overwritten on update.
# Instead add/change your variables in /etc/default/gitlab
# An example defaults file can be found in lib/support/init.d/gitlab.default.example
###


### Environment variables
RAILS_ENV="production"

# Script variable names should be lower-case not to conflict with
# internal /bin/sh variables such as PATH, EDITOR or SHELL.
app_user="git"
app_root="/home/$app_user/gitlab"
pid_path="$app_root/tmp/pids"
socket_path="$app_root/tmp/sockets"
web_server_pid_path="$pid_path/unicorn.pid"
sidekiq_pid_path="$pid_path/sidekiq.pid"
mail_room_enabled=false
mail_room_pid_path="$pid_path/mail_room.pid"
gitlab_workhorse_pid_path="$pid_path/gitlab-workhorse.pid"
gitlab_workhorse_options="-listenUmask 0 -listenNetwork unix -listenAddr $socket_path/gitlab-workhorse.socket -authBackend http://127.0.0.1:8080"
gitlab_workhorse_log="$app_root/log/gitlab-workhorse.log"
shell_path="/bin/bash"

# Read configuration variable file if it is present
test -f /etc/default/gitlab && . /etc/default/gitlab

# Switch to the app_user if it is not he/she who is running the script.
if [ `whoami` != "$app_user" ]; then
  eval su - "$app_user" -s $shell_path -c $(echo \")$0 "$@"$(echo \"); exit;
fi

# Switch to the gitlab path, exit on failure.
if ! cd "$app_root" ; then
 echo "Failed to cd into $app_root, exiting!";  exit 1
fi


### Init Script functions

## Gets the pids from the files
check_pids(){
  if ! mkdir -p "$pid_path"; then
    echo "Could not create the path $pid_path needed to store the pids."
    exit 1
  fi
  # If there exists a file which should hold the value of the Unicorn pid: read it.
  if [ -f "$web_server_pid_path" ]; then
    wpid=$(cat "$web_server_pid_path")
  else
    wpid=0
  fi
  if [ -f "$sidekiq_pid_path" ]; then
    spid=$(cat "$sidekiq_pid_path")
  else
    spid=0
  fi
  if [ -f "$gitlab_workhorse_pid_path" ]; then
    hpid=$(cat "$gitlab_workhorse_pid_path")
  else
    hpid=0
  fi
  if [ "$mail_room_enabled" = true ]; then
    if [ -f "$mail_room_pid_path" ]; then
      mpid=$(cat "$mail_room_pid_path")
    else
      mpid=0
    fi
  fi
}

## Called when we have started the two processes and are waiting for their pid files.
wait_for_pids(){
  # We are sleeping a bit here mostly because sidekiq is slow at writing it's pid
  i=0;
  while [ ! -f $web_server_pid_path ] || [ ! -f $sidekiq_pid_path ] || [ ! -f $gitlab_workhorse_pid_path ] || { [ "$mail_room_enabled" = true ] && [ ! -f $mail_room_pid_path ]; }; do
    sleep 0.1;
    i=$((i+1))
    if [ $((i%10)) = 0 ]; then
      echo -n "."
    elif [ $((i)) = 301 ]; then
      echo "Waited 30s for the processes to write their pids, something probably went wrong."
      exit 1;
    fi
  done
  echo
}

# We use the pids in so many parts of the script it makes sense to always check them.
# Only after start() is run should the pids change. Sidekiq sets it's own pid.
check_pids


## Checks whether the different parts of the service are already running or not.
check_status(){
  check_pids
  # If the web server is running kill -0 $wpid returns true, or rather 0.
  # Checks of *_status should only check for == 0 or != 0, never anything else.
  if [ $wpid -ne 0 ]; then
    kill -0 "$wpid" 2>/dev/null
    web_status="$?"
  else
    web_status="-1"
  fi
  if [ $spid -ne 0 ]; then
    kill -0 "$spid" 2>/dev/null
    sidekiq_status="$?"
  else
    sidekiq_status="-1"
  fi
  if [ $hpid -ne 0 ]; then
    kill -0 "$hpid" 2>/dev/null
    gitlab_workhorse_status="$?"
  else
    gitlab_workhorse_status="-1"
  fi
  if [ "$mail_room_enabled" = true ]; then
    if [ $mpid -ne 0 ]; then
      kill -0 "$mpid" 2>/dev/null
      mail_room_status="$?"
    else
      mail_room_status="-1"
    fi
  fi
  if [ $web_status = 0 ] && [ $sidekiq_status = 0 ] && [ $gitlab_workhorse_status = 0 ] && { [ "$mail_room_enabled" != true ] || [ $mail_room_status = 0 ]; }; then
    gitlab_status=0
  else
    # http://refspecs.linuxbase.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html
    # code 3 means 'program is not running'
    gitlab_status=3
  fi
}

## Check for stale pids and remove them if necessary.
check_stale_pids(){
  check_status
  # If there is a pid it is something else than 0, the service is running if
  # *_status is == 0.
  if [ "$wpid" != "0" ] && [ "$web_status" != "0" ]; then
    echo "Removing stale Unicorn web server pid. This is most likely caused by the web server crashing the last time it ran."
    if ! rm "$web_server_pid_path"; then
      echo "Unable to remove stale pid, exiting."
      exit 1
    fi
  fi
  if [ "$spid" != "0" ] && [ "$sidekiq_status" != "0" ]; then
    echo "Removing stale Sidekiq job dispatcher pid. This is most likely caused by Sidekiq crashing the last time it ran."
    if ! rm "$sidekiq_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
  if [ "$hpid" != "0" ] && [ "$gitlab_workhorse_status" != "0" ]; then
    echo "Removing stale gitlab-workhorse pid. This is most likely caused by gitlab-workhorse crashing the last time it ran."
    if ! rm "$gitlab_workhorse_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
  if [ "$mail_room_enabled" = true ] && [ "$mpid" != "0" ] && [ "$mail_room_status" != "0" ]; then
    echo "Removing stale MailRoom job dispatcher pid. This is most likely caused by MailRoom crashing the last time it ran."
    if ! rm "$mail_room_pid_path"; then
      echo "Unable to remove stale pid, exiting"
      exit 1
    fi
  fi
}

## If no parts of the service is running, bail out.
exit_if_not_running(){
  check_stale_pids
  if [ "$web_status" != "0" ] && [ "$sidekiq_status" != "0" ] && [ "$gitlab_workhorse_status" != "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" != "0" ]; }; then
    echo "GitLab is not running."
    exit
  fi
}

## Starts Unicorn and Sidekiq if they're not running.
start_gitlab() {
  check_stale_pids

  if [ "$web_status" != "0" ]; then
    echo "Starting GitLab Unicorn"
  fi
  if [ "$sidekiq_status" != "0" ]; then
    echo "Starting GitLab Sidekiq"
  fi
  if [ "$gitlab_workhorse_status" != "0" ]; then
    echo "Starting gitlab-workhorse"
  fi
  if [ "$mail_room_enabled" = true ] && [ "$mail_room_status" != "0" ]; then
    echo "Starting GitLab MailRoom"
  fi

  # Then check if the service is running. If it is: don't start again.
  if [ "$web_status" = "0" ]; then
    echo "The Unicorn web server already running with pid $wpid, not restarting."
  else
    # Remove old socket if it exists
    rm -f "$socket_path"/gitlab.socket 2>/dev/null
    # Start the web server
    RAILS_ENV=$RAILS_ENV bin/web start
  fi

  # If sidekiq is already running, don't start it again.
  if [ "$sidekiq_status" = "0" ]; then
    echo "The Sidekiq job dispatcher is already running with pid $spid, not restarting"
  else
    RAILS_ENV=$RAILS_ENV bin/background_jobs start &
  fi

  if [ "$gitlab_workhorse_status" = "0" ]; then
    echo "The gitlab-workhorse is already running with pid $spid, not restarting"
  else
    # No need to remove a socket, gitlab-workhorse does this itself
    $app_root/bin/daemon_with_pidfile $gitlab_workhorse_pid_path  \
      $app_root/../gitlab-workhorse/gitlab-workhorse \
        $gitlab_workhorse_options \
      >> $gitlab_workhorse_log 2>&1 &
  fi

  if [ "$mail_room_enabled" = true ]; then
    # If MailRoom is already running, don't start it again.
    if [ "$mail_room_status" = "0" ]; then
      echo "The MailRoom email processor is already running with pid $mpid, not restarting"
    else
      RAILS_ENV=$RAILS_ENV bin/mail_room start &
    fi
  fi

  # Wait for the pids to be planted
  wait_for_pids
  # Finally check the status to tell wether or not GitLab is running
  print_status
}

## Asks Unicorn, Sidekiq and MailRoom if they would be so kind as to stop, if not kills them.
stop_gitlab() {
  exit_if_not_running

  if [ "$web_status" = "0" ]; then
    echo "Shutting down GitLab Unicorn"
    RAILS_ENV=$RAILS_ENV bin/web stop
  fi
  if [ "$sidekiq_status" = "0" ]; then
    echo "Shutting down GitLab Sidekiq"
    RAILS_ENV=$RAILS_ENV bin/background_jobs stop
  fi
  if [ "$gitlab_workhorse_status" = "0" ]; then
    echo "Shutting down gitlab-workhorse"
    kill -- $(cat $gitlab_workhorse_pid_path)
  fi
  if [ "$mail_room_enabled" = true ] && [ "$mail_room_status" = "0" ]; then
    echo "Shutting down GitLab MailRoom"
    RAILS_ENV=$RAILS_ENV bin/mail_room stop
  fi

  # If something needs to be stopped, lets wait for it to stop. Never use SIGKILL in a script.
  while [ "$web_status" = "0" ] || [ "$sidekiq_status" = "0" ] || [ "$gitlab_workhorse_status" = "0" ] || { [ "$mail_room_enabled" = true ] && [ "$mail_room_status" = "0" ]; }; do
    sleep 1
    check_status
    printf "."
    if [ "$web_status" != "0" ] && [ "$sidekiq_status" != "0" ] && [ "$gitlab_workhorse_status" != "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" != "0" ]; }; then
      printf "\n"
      break
    fi
  done

  sleep 1
  # Cleaning up unused pids
  rm "$web_server_pid_path" 2>/dev/null
  # rm "$sidekiq_pid_path" 2>/dev/null # Sidekiq seems to be cleaning up it's own pid.
  rm -f "$gitlab_workhorse_pid_path"
  if [ "$mail_room_enabled" = true ]; then
    rm "$mail_room_pid_path" 2>/dev/null
  fi

  print_status
}

## Prints the status of GitLab and it's components.
print_status() {
  check_status
  if [ "$web_status" != "0" ] && [ "$sidekiq_status" != "0" ] && [ "$gitlab_workhorse_status" != "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" != "0" ]; }; then
    echo "GitLab is not running."
    return
  fi
  if [ "$web_status" = "0" ]; then
      echo "The GitLab Unicorn web server with pid $wpid is running."
  else
      printf "The GitLab Unicorn web server is \033[31mnot running\033[0m.\n"
  fi
  if [ "$sidekiq_status" = "0" ]; then
      echo "The GitLab Sidekiq job dispatcher with pid $spid is running."
  else
      printf "The GitLab Sidekiq job dispatcher is \033[31mnot running\033[0m.\n"
  fi
  if [ "$gitlab_workhorse_status" = "0" ]; then
      echo "The gitlab-workhorse with pid $hpid is running."
  else
      printf "The gitlab-workhorse is \033[31mnot running\033[0m.\n"
  fi
  if [ "$mail_room_enabled" = true ]; then
    if [ "$mail_room_status" = "0" ]; then
        echo "The GitLab MailRoom email processor with pid $mpid is running."
    else
        printf "The GitLab MailRoom email processor is \033[31mnot running\033[0m.\n"
    fi
  fi
  if [ "$web_status" = "0" ] && [ "$sidekiq_status" = "0" ] && { [ "$mail_room_enabled" != true ] || [ "$mail_room_status" = "0" ]; }; then
    printf "GitLab and all its components are \033[32mup and running\033[0m.\n"
  fi
}

## Tells unicorn to reload it's config and Sidekiq to restart
reload_gitlab(){
  exit_if_not_running
  if [ "$wpid" = "0" ];then
    echo "The GitLab Unicorn Web server is not running thus its configuration can't be reloaded."
    exit 1
  fi
  printf "Reloading GitLab Unicorn configuration... "
  RAILS_ENV=$RAILS_ENV bin/web reload
  echo "Done."

  echo "Restarting GitLab Sidekiq since it isn't capable of reloading its config..."
  RAILS_ENV=$RAILS_ENV bin/background_jobs restart

  if [ "$mail_room_enabled" != true ]; then
    echo "Restarting GitLab MailRoom since it isn't capable of reloading its config..."
    RAILS_ENV=$RAILS_ENV bin/mail_room restart
  fi

  wait_for_pids
  print_status
}

## Restarts Sidekiq and Unicorn.
restart_gitlab(){
  check_status
  if [ "$web_status" = "0" ] || [ "$sidekiq_status" = "0" ] || [ "$gitlab_workhorse" = "0" ] || { [ "$mail_room_enabled" = true ] && [ "$mail_room_status" = "0" ]; }; then
    stop_gitlab
  fi
  start_gitlab
}


### Finally the input handling.

case "$1" in
  start)
        start_gitlab
        ;;
  stop)
        stop_gitlab
        ;;
  restart)
        restart_gitlab
        ;;
  reload|force-reload)
	reload_gitlab
        ;;
  status)
        print_status
        exit $gitlab_status
        ;;
  *)
        echo "Usage: service gitlab {start|stop|restart|reload|status}"
        exit 1
        ;;
esac

exit
