# frozen_string_literal: true

module Banzai
  module Filter
    # TaskListFilter annotates task list items with aria-labels, adds strikethroughs
    # to the text body of inapplicable items (created with `[~]`).
    #
    # This should be run on the HTML generated by the Markdown filter, which handles the actual
    # parsing, after the SanitizationFilter.
    class TaskListFilter < HTML::Pipeline::Filter
      prepend Concerns::PipelineTimingCheck

      CSS   = 'input.task-list-item-checkbox'
      XPATH = Gitlab::Utils::Nokogiri.css_to_xpath(CSS).freeze

      def call
        doc.xpath(XPATH).each do |node|
          text_content = self.class.text_for_task_item_from_input(node)
          truncated_text_content = text_content.truncate(100, separator: ' ', omission: 'â€¦')
          node['aria-label'] = format(_('Check option: %{option}'), option: truncated_text_content)

          next unless node.has_attribute?('data-inapplicable')

          # We manually apply a <s> to strikethrough text in inapplicable task items,
          # specifically in tight lists where text within the list items isn't contained in a paragraph.
          # (Those are handled entirely by styles.)
          #
          # To handle tight lists, we wrap every text node after the checkbox in <s>, not descending
          # into <p> or <div> (as they're indicative of non-tight lists) or <ul> or <ol> (as we
          # explicitly want to avoid strikethrough styles on sublists, which may have applicable
          # task items!).

          # This is awkward, but we need to include a text node with a space after the input.
          # Otherwise, the strikethrough will start *immediately* next to the <input>, because
          # the first next sibling of the input is always a text node that starts with a space!
          space = node.add_next_sibling(node.document.create_text_node(' '))

          inapplicable_s = node.document.create_element('s')
          inapplicable_s['class'] = 'inapplicable'

          self.class.yield_text_nodes_without_descending_into(space.next_sibling, %w[p div ul ol]) do |el|
            el.wrap(inapplicable_s)
          end
        end

        doc
      end

      class << self
        # Gets the text for the task list item, given the <input> checkbox that declares it.
        def text_for_task_item_from_input(input)
          text_content = +''
          yield_next_siblings_until(input, %w[ol ul]) do |el|
            text_content << el.text
          end
          text_content.strip
        end

        # Gets the HTML corresponding to the task list item text, given the <input> checkbox that declares it.
        # This should be used for task list item matching **only**; see Taskable.get_tasks. We never return
        # this to the user.
        def text_html_for_task_item_from_input(input)
          html_content = +''
          yield_next_siblings_until(input, %w[ol ul]) do |el|
            html_content << el.to_html
          end
          html_content
        end

        # Yields the #next_sibling of start, and then the #next_sibling of that, until either
        # there are no more next siblings or a matching element is encountered.
        #
        # The following #next_sibling is evaluated *before* each element is yielded, so they
        # can safely be reparented or removed without affecting iteration.
        def yield_next_siblings_until(start, els)
          it = start.next_sibling
          while it && els.exclude?(it.name)
            following = it.next_sibling
            yield it
            it = following
          end
        end

        # Starting from start, iteratively yield text nodes contained within its children,
        # and its (repeated) #next_siblings and their children, not descending into any of
        # the elements given by els.
        #
        # The following #next_sibling is evaluated before yielding, as above.
        def yield_text_nodes_without_descending_into(start, els)
          stack = [start]
          while stack.any?
            it = stack.pop

            stack << it.next_sibling if it.next_sibling

            if it.text?
              yield it unless it.content.blank?
            elsif els.exclude?(it.name)
              stack << it.children.first if it.children.first
            end
          end
        end
      end
    end
  end
end
