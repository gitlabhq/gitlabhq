# frozen_string_literal: true

module Gitlab
  module Page
    module Subscriptions
      module New
        # @note Defined as +select :plan_name+
        # @return [String] The text content or value of +plan_name+
        def plan_name
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.plan_name_element).to exist
        #   end
        # @return [Watir::Select] The raw +Select+ element
        def plan_name_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_plan_name
        #   end
        # @return [Boolean] true if the +plan_name+ element is present on the page
        def plan_name?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +select :group_name+
        # @return [String] The text content or value of +group_name+
        def group_name
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.group_name_element).to exist
        #   end
        # @return [Watir::Select] The raw +Select+ element
        def group_name_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_group_name
        #   end
        # @return [Boolean] true if the +group_name+ element is present on the page
        def group_name?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :number_of_users+
        # @return [String] The text content or value of +number_of_users+
        def number_of_users
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of number_of_users
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.number_of_users = 'value'
        #   end
        # @param value [String] The value to set.
        def number_of_users=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.number_of_users_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def number_of_users_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_number_of_users
        #   end
        # @return [Boolean] true if the +number_of_users+ element is present on the page
        def number_of_users?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :quantity+
        # @return [String] The text content or value of +quantity+
        def quantity
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of quantity
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.quantity = 'value'
        #   end
        # @param value [String] The value to set.
        def quantity=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.quantity_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def quantity_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_quantity
        #   end
        # @return [Boolean] true if the +quantity+ element is present on the page
        def quantity?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +button :continue_to_billing+
        # Clicks +continue_to_billing+
        def continue_to_billing
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.continue_to_billing_element).to exist
        #   end
        # @return [Watir::Button] The raw +Button+ element
        def continue_to_billing_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_continue_to_billing
        #   end
        # @return [Boolean] true if the +continue_to_billing+ element is present on the page
        def continue_to_billing?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +select :country+
        # @return [String] The text content or value of +country+
        def country
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.country_element).to exist
        #   end
        # @return [Watir::Select] The raw +Select+ element
        def country_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_country
        #   end
        # @return [Boolean] true if the +country+ element is present on the page
        def country?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :street_address_1+
        # @return [String] The text content or value of +street_address_1+
        def street_address_1
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of street_address_1
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.street_address_1 = 'value'
        #   end
        # @param value [String] The value to set.
        def street_address_1=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.street_address_1_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def street_address_1_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_street_address_1
        #   end
        # @return [Boolean] true if the +street_address_1+ element is present on the page
        def street_address_1?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :street_address_2+
        # @return [String] The text content or value of +street_address_2+
        def street_address_2
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of street_address_2
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.street_address_2 = 'value'
        #   end
        # @param value [String] The value to set.
        def street_address_2=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.street_address_2_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def street_address_2_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_street_address_2
        #   end
        # @return [Boolean] true if the +street_address_2+ element is present on the page
        def street_address_2?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :city+
        # @return [String] The text content or value of +city+
        def city
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of city
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.city = 'value'
        #   end
        # @param value [String] The value to set.
        def city=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.city_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def city_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_city
        #   end
        # @return [Boolean] true if the +city+ element is present on the page
        def city?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +select :state+
        # @return [String] The text content or value of +state+
        def state
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.state_element).to exist
        #   end
        # @return [Watir::Select] The raw +Select+ element
        def state_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_state
        #   end
        # @return [Boolean] true if the +state+ element is present on the page
        def state?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :zip_code+
        # @return [String] The text content or value of +zip_code+
        def zip_code
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of zip_code
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.zip_code = 'value'
        #   end
        # @param value [String] The value to set.
        def zip_code=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.zip_code_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def zip_code_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_zip_code
        #   end
        # @return [Boolean] true if the +zip_code+ element is present on the page
        def zip_code?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +button :continue_to_payment+
        # Clicks +continue_to_payment+
        def continue_to_payment
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.continue_to_payment_element).to exist
        #   end
        # @return [Watir::Button] The raw +Button+ element
        def continue_to_payment_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_continue_to_payment
        #   end
        # @return [Boolean] true if the +continue_to_payment+ element is present on the page
        def continue_to_payment?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +iframe :payment_form+
        # @return [String] The text content or value of +payment_form+
        def payment_form
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.payment_form_element).to exist
        #   end
        # @return [Watir::Iframe] The raw +Iframe+ element
        def payment_form_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_payment_form
        #   end
        # @return [Boolean] true if the +payment_form+ element is present on the page
        def payment_form?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :name_on_card+
        # @return [String] The text content or value of +name_on_card+
        def name_on_card
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of name_on_card
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.name_on_card = 'value'
        #   end
        # @param value [String] The value to set.
        def name_on_card=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.name_on_card_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def name_on_card_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_name_on_card
        #   end
        # @return [Boolean] true if the +name_on_card+ element is present on the page
        def name_on_card?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :card_number+
        # @return [String] The text content or value of +card_number+
        def card_number
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of card_number
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.card_number = 'value'
        #   end
        # @param value [String] The value to set.
        def card_number=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.card_number_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def card_number_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_card_number
        #   end
        # @return [Boolean] true if the +card_number+ element is present on the page
        def card_number?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +select :expiration_month+
        # @return [String] The text content or value of +expiration_month+
        def expiration_month
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.expiration_month_element).to exist
        #   end
        # @return [Watir::Select] The raw +Select+ element
        def expiration_month_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_expiration_month
        #   end
        # @return [Boolean] true if the +expiration_month+ element is present on the page
        def expiration_month?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +select :expiration_year+
        # @return [String] The text content or value of +expiration_year+
        def expiration_year
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.expiration_year_element).to exist
        #   end
        # @return [Watir::Select] The raw +Select+ element
        def expiration_year_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_expiration_year
        #   end
        # @return [Boolean] true if the +expiration_year+ element is present on the page
        def expiration_year?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +text_field :cvv+
        # @return [String] The text content or value of +cvv+
        def cvv
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # Set the value of cvv
        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     new.cvv = 'value'
        #   end
        # @param value [String] The value to set.
        def cvv=(value)
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.cvv_element).to exist
        #   end
        # @return [Watir::TextField] The raw +TextField+ element
        def cvv_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_cvv
        #   end
        # @return [Boolean] true if the +cvv+ element is present on the page
        def cvv?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +link :review_your_order+
        # Clicks +review_your_order+
        def review_your_order
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.review_your_order_element).to exist
        #   end
        # @return [Watir::Link] The raw +Link+ element
        def review_your_order_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_review_your_order
        #   end
        # @return [Boolean] true if the +review_your_order+ element is present on the page
        def review_your_order?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +button :confirm_purchase+
        # Clicks +confirm_purchase+
        def confirm_purchase
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.confirm_purchase_element).to exist
        #   end
        # @return [Watir::Button] The raw +Button+ element
        def confirm_purchase_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_confirm_purchase
        #   end
        # @return [Boolean] true if the +confirm_purchase+ element is present on the page
        def confirm_purchase?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +div :selected_plan+
        # @return [String] The text content or value of +selected_plan+
        def selected_plan
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.selected_plan_element).to exist
        #   end
        # @return [Watir::Div] The raw +Div+ element
        def selected_plan_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_selected_plan
        #   end
        # @return [Boolean] true if the +selected_plan+ element is present on the page
        def selected_plan?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +div :total_amount+
        # @return [String] The text content or value of +total_amount+
        def total_amount
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.total_amount_element).to exist
        #   end
        # @return [Watir::Div] The raw +Div+ element
        def total_amount_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_total_amount
        #   end
        # @return [Boolean] true if the +total_amount+ element is present on the page
        def total_amount?
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @note Defined as +div :lock_competition_error+
        # @return [String] The text content or value of +lock_competition_error+
        def lock_competition_error
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new.lock_competition_error_element).to exist
        #   end
        # @return [Watir::Div] The raw +Div+ element
        def lock_competition_error_element
          # This is a stub, used for indexing. The method is dynamically generated.
        end

        # @example
        #   Gitlab::Page::Subscriptions::New.perform do |new|
        #     expect(new).to be_lock_competition_error
        #   end
        # @return [Boolean] true if the +lock_competition_error+ element is present on the page
        def lock_competition_error?
          # This is a stub, used for indexing. The method is dynamically generated.
        end
      end
    end
  end
end
