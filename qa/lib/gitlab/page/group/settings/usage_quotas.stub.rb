# frozen_string_literal: true

module Gitlab
  module Page
    module Group
      module Settings
        module UsageQuotas
          # @note Defined as +div :seats_in_use+
          # @return [String] The text content or value of +seats_in_use+
          def seats_in_use
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.seats_in_use_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def seats_in_use_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_seats_in_use
          #   end
          # @return [Boolean] true if the +seats_in_use+ element is present on the page
          def seats_in_use?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +p :seats_used+
          # @return [String] The text content or value of +seats_used+
          def seats_used
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.seats_used_element).to exist
          #   end
          # @return [Watir::P] The raw +P+ element
          def seats_used_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_seats_used
          #   end
          # @return [Boolean] true if the +seats_used+ element is present on the page
          def seats_used?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +p :seats_owed+
          # @return [String] The text content or value of +seats_owed+
          def seats_owed
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.seats_owed_element).to exist
          #   end
          # @return [Watir::P] The raw +P+ element
          def seats_owed_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_seats_owed
          #   end
          # @return [Boolean] true if the +seats_owed+ element is present on the page
          def seats_owed?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +table :subscription_users+
          # @return [String] The text content or value of +subscription_users+
          def subscription_users
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.subscription_users_element).to exist
          #   end
          # @return [Watir::Table] The raw +Table+ element
          def subscription_users_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_subscription_users
          #   end
          # @return [Boolean] true if the +subscription_users+ element is present on the page
          def subscription_users?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :pipelines_tab+
          # Clicks +pipelines_tab+
          def pipelines_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.pipelines_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def pipelines_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_pipelines_tab
          #   end
          # @return [Boolean] true if the +pipelines_tab+ element is present on the page
          def pipelines_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :buy_compute_minutes+
          # Clicks +buy_compute_minutes+
          def buy_compute_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.buy_compute_minutes_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def buy_compute_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_buy_compute_minutes
          #   end
          # @return [Boolean] true if the +buy_compute_minutes+ element is present on the page
          def buy_compute_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :plan_compute_minutes+
          # @return [String] The text content or value of +plan_compute_minutes+
          def plan_compute_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.plan_compute_minutes_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def plan_compute_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_plan_compute_minutes
          #   end
          # @return [Boolean] true if the +plan_compute_minutes+ element is present on the page
          def plan_compute_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :additional_compute_minutes+
          # @return [String] The text content or value of +additional_compute_minutes+
          def additional_compute_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.additional_compute_minutes_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def additional_compute_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_additional_compute_minutes
          #   end
          # @return [Boolean] true if the +additional_compute_minutes+ element is present on the page
          def additional_compute_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :ci_purchase_successful_alert+
          # @return [String] The text content or value of +ci_purchase_successful_alert+
          def ci_purchase_successful_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.ci_purchase_successful_alert_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def ci_purchase_successful_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_ci_purchase_successful_alert
          #   end
          # @return [Boolean] true if the +ci_purchase_successful_alert+ element is present on the page
          def ci_purchase_successful_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :storage_tab+
          # Clicks +storage_tab+
          def storage_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def storage_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_tab
          #   end
          # @return [Boolean] true if the +storage_tab+ element is present on the page
          def storage_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :purchase_more_storage+
          # Clicks +purchase_more_storage+
          def purchase_more_storage
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.purchase_more_storage_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def purchase_more_storage_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_purchase_more_storage
          #   end
          # @return [Boolean] true if the +purchase_more_storage+ element is present on the page
          def purchase_more_storage?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :used_storage_message+
          # @return [String] The text content or value of +used_storage_message+
          def used_storage_message
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.used_storage_message_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def used_storage_message_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_used_storage_message
          #   end
          # @return [Boolean] true if the +used_storage_message+ element is present on the page
          def used_storage_message?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :group_usage_message+
          # @return [String] The text content or value of +group_usage_message+
          def group_usage_message
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.group_usage_message_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def group_usage_message_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_group_usage_message
          #   end
          # @return [Boolean] true if the +group_usage_message+ element is present on the page
          def group_usage_message?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +span :dependency_proxy_size+
          # @return [String] The text content or value of +dependency_proxy_size+
          def dependency_proxy_size
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.dependency_proxy_size_element).to exist
          #   end
          # @return [Watir::Span] The raw +Span+ element
          def dependency_proxy_size_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_dependency_proxy_size
          #   end
          # @return [Boolean] true if the +dependency_proxy_size+ element is present on the page
          def dependency_proxy_size?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :project_storage_used+
          # @return [String] The text content or value of +project_storage_used+
          def project_storage_used
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.project_storage_used_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def project_storage_used_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_project_storage_used
          #   end
          # @return [Boolean] true if the +project_storage_used+ element is present on the page
          def project_storage_used?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :project+
          # @return [String] The text content or value of +project+
          def project
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.project_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def project_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_project
          #   end
          # @return [Boolean] true if the +project+ element is present on the page
          def project?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :storage_purchased+
          # @return [String] The text content or value of +storage_purchased+
          def storage_purchased
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_purchased_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def storage_purchased_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_purchased
          #   end
          # @return [Boolean] true if the +storage_purchased+ element is present on the page
          def storage_purchased?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :storage_purchase_successful_alert+
          # @return [String] The text content or value of +storage_purchase_successful_alert+
          def storage_purchase_successful_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_purchase_successful_alert_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def storage_purchase_successful_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_purchase_successful_alert
          #   end
          # @return [Boolean] true if the +storage_purchase_successful_alert+ element is present on the page
          def storage_purchase_successful_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +h2 :storage_available_alert+
          # @return [String] The text content or value of +storage_available_alert+
          def storage_available_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas.storage_available_alert_element).to exist
          #   end
          # @return [Watir::H2] The raw +H2+ element
          def storage_available_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuotas.perform do |usage_quotas|
          #     expect(usage_quotas).to be_storage_available_alert
          #   end
          # @return [Boolean] true if the +storage_available_alert+ element is present on the page
          def storage_available_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end
        end
      end
    end
  end
end
