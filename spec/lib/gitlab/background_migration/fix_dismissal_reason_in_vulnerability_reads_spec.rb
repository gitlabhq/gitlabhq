# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::BackgroundMigration::FixDismissalReasonInVulnerabilityReads, :migration, migration: :gitlab_sec, feature_category: :vulnerability_management do
  include BatchedBackgroundMigrationHelpers::V1::TableHelpers

  tables :namespaces, :organizations, :projects, :users, :vulnerabilities, :vulnerability_reads,
    :vulnerability_state_transitions, :vulnerability_occurrences, :vulnerability_scanners, :vulnerability_identifiers

  configure_table :vulnerabilities, database: :sec
  configure_table :vulnerability_reads, database: :sec
  configure_table :vulnerability_state_transitions, database: :sec
  configure_table :vulnerability_occurrences, database: :sec
  configure_table :vulnerability_scanners, database: :sec
  configure_table :vulnerability_identifiers, database: :sec

  let(:organization) { organizations.create!(name: 'test', path: 'test') }
  let(:namespace) do
    namespaces.create!(name: 'test', path: 'test', type: 'Group', organization_id: organization.id)
  end

  let(:project_namespace) do
    namespaces.create!(name: 'test-project', path: 'test-project', type: 'Project',
      organization_id: organization.id)
  end

  let(:project) do
    projects.create!(
      namespace_id: namespace.id,
      project_namespace_id: project_namespace.id,
      name: 'test',
      organization_id: organization.id
    )
  end

  let(:user) do
    users.create!(
      name: 'test_user',
      email: 'test@example.com',
      username: 'test_user',
      projects_limit: 10,
      organization_id: organization.id
    )
  end

  let(:scanner) do
    vulnerability_scanners.create!(
      project_id: project.id,
      external_id: 'scanner',
      name: 'Scanner'
    )
  end

  let(:identifier) do
    vulnerability_identifiers.create!(
      project_id: project.id,
      fingerprint: SecureRandom.hex(20),
      external_type: 'cve',
      external_id: 'CVE-2021-1234',
      name: 'CVE-2021-1234'
    )
  end

  let(:dismissed_state) { 2 }
  let(:detected_state) { 1 }

  let(:dismissal_reason_false_positive) { 0 }
  let(:dismissal_reason_acceptable_risk) { 1 }
  let(:dismissal_reason_mitigating_control) { 2 }
  let(:dismissal_reason_used_in_tests) { 3 }
  let(:dismissal_reason_not_applicable) { 4 }

  def create_vulnerability(state:)
    occurrence = vulnerability_occurrences.create!(
      project_id: project.id,
      scanner_id: scanner.id,
      primary_identifier_id: identifier.id,
      name: 'Finding',
      severity: 0,
      report_type: 0,
      uuid: SecureRandom.uuid,
      location_fingerprint: SecureRandom.hex(20),
      metadata_version: '1.0',
      raw_metadata: '{}'
    )

    vulnerability = vulnerabilities.create!(
      project_id: project.id,
      author_id: user.id,
      finding_id: occurrence.id,
      title: 'Test Vulnerability',
      severity: 0,
      report_type: 0,
      state: state
    )

    vulnerability_occurrences.where(id: occurrence.id).update_all(
      vulnerability_id: vulnerability.id
    )

    # Update the automatically created vulnerability_read to match the vulnerability state
    vulnerability_reads.where(vulnerability_id: vulnerability.id).update_all(
      state: state
    )

    vulnerability
  end

  subject(:perform_migration) do
    described_class.new(
      start_id: vulnerability_reads.minimum(:id),
      end_id: vulnerability_reads.maximum(:id),
      batch_table: :vulnerability_reads,
      batch_column: :id,
      sub_batch_size: 100,
      pause_ms: 0,
      connection: SecApplicationRecord.connection
    ).perform
  end

  describe '#perform' do
    context 'when there are dismissed vulnerabilities with missing dismissal_reason' do
      it 'updates dismissal_reason from the latest state transition' do
        vulnerability = create_vulnerability(state: dismissed_state)

        # Get the automatically created vulnerability_read
        vulnerability_read = vulnerability_reads.find_by(vulnerability_id: vulnerability.id)

        # Create a state transition with dismissal_reason
        vulnerability_state_transitions.create!(
          vulnerability_id: vulnerability.id,
          from_state: detected_state,
          to_state: dismissed_state,
          dismissal_reason: dismissal_reason_false_positive
        )

        perform_migration

        expect(vulnerability_read.reload.dismissal_reason).to eq(dismissal_reason_false_positive)
      end
    end

    context 'when there are multiple dismissed vulnerabilities' do
      it 'updates all of them with their respective dismissal reasons' do
        vuln_list = Array.new(3) do
          create_vulnerability(state: dismissed_state)
        end

        vulnerability_reads_list = vuln_list.map do |vuln|
          vulnerability_reads.find_by(vulnerability_id: vuln.id)
        end

        dismissal_reasons = [
          dismissal_reason_false_positive,
          dismissal_reason_acceptable_risk,
          dismissal_reason_mitigating_control
        ]

        vuln_list.each_with_index do |vuln, i|
          vulnerability_state_transitions.create!(
            vulnerability_id: vuln.id,
            from_state: detected_state,
            to_state: dismissed_state,
            dismissal_reason: dismissal_reasons[i]
          )
        end

        perform_migration

        vulnerability_reads_list.each_with_index do |read, i|
          expect(read.reload.dismissal_reason).to eq(dismissal_reasons[i])
        end
      end
    end

    context 'when vulnerability_read already has a dismissal_reason' do
      it 'does not update it' do
        vulnerability = create_vulnerability(state: dismissed_state)

        existing_reason = dismissal_reason_acceptable_risk
        vulnerability_read = vulnerability_reads.find_by(vulnerability_id: vulnerability.id)
        vulnerability_reads.where(id: vulnerability_read.id).update_all(
          dismissal_reason: existing_reason
        )

        # Create a different state transition
        vulnerability_state_transitions.create!(
          vulnerability_id: vulnerability.id,
          from_state: detected_state,
          to_state: dismissed_state,
          dismissal_reason: dismissal_reason_false_positive
        )

        perform_migration

        expect(vulnerability_read.reload.dismissal_reason).to eq(existing_reason)
      end
    end

    context 'when vulnerability_read is not in dismissed state' do
      it 'does not update it' do
        vulnerability = create_vulnerability(state: detected_state)

        vulnerability_read = vulnerability_reads.find_by(vulnerability_id: vulnerability.id)

        perform_migration

        expect(vulnerability_read.reload.dismissal_reason).to be_nil
      end
    end

    context 'when state transition has no dismissal_reason' do
      it 'does not update the vulnerability_read' do
        vulnerability = create_vulnerability(state: dismissed_state)

        vulnerability_read = vulnerability_reads.find_by(vulnerability_id: vulnerability.id)

        # Create a state transition without dismissal_reason
        vulnerability_state_transitions.create!(
          vulnerability_id: vulnerability.id,
          from_state: detected_state,
          to_state: dismissed_state,
          dismissal_reason: nil
        )

        perform_migration

        expect(vulnerability_read.reload.dismissal_reason).to be_nil
      end
    end

    context 'when there are multiple state transitions for the same vulnerability' do
      it 'uses the latest one' do
        vulnerability = create_vulnerability(state: dismissed_state)

        vulnerability_read = vulnerability_reads.find_by(vulnerability_id: vulnerability.id)

        # Create multiple state transitions
        vulnerability_state_transitions.create!(
          vulnerability_id: vulnerability.id,
          from_state: detected_state,
          to_state: dismissed_state,
          dismissal_reason: dismissal_reason_false_positive
        )

        vulnerability_state_transitions.create!(
          vulnerability_id: vulnerability.id,
          from_state: detected_state,
          to_state: dismissed_state,
          dismissal_reason: dismissal_reason_acceptable_risk
        )

        perform_migration

        expect(vulnerability_read.reload.dismissal_reason).to eq(dismissal_reason_acceptable_risk)
      end
    end

    context 'when there are no dismissed vulnerabilities with missing dismissal_reason' do
      it 'does not raise an error' do
        vulnerability = create_vulnerability(state: detected_state)

        vulnerability_reads.find_by(vulnerability_id: vulnerability.id)

        expect { perform_migration }.not_to raise_error
      end
    end

    context 'when batch is empty' do
      it 'does not raise an error' do
        expect { perform_migration }.not_to raise_error
      end
    end
  end
end
