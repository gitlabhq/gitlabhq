# frozen_string_literal: true

require 'spec_helper'

# RSpec.describe Tasks::Gitlab::Permissions::Routes::DocsTask, :silence_stdout, feature_category: :permissions do
RSpec.describe Tasks::Gitlab::Permissions::Routes::DocsTask, feature_category: :permissions do
  let(:task) { described_class.new }
  let(:path) { Rails.root.join('tmp/tests/doc/gitlab/permissions/routes/') }
  let(:doc) { 'granular_pat_rest_api_endpoints.md' }
  let(:doc_path) { Rails.root.join(path, doc) }
  let(:routes) do
    [
      delete_package_route,
      download_package_route,
      upload_package_route,
      read_job_route
    ]
  end

  let(:read_job_assignable) do
    instance_double(::Authz::PermissionGroups::Assignable,
      category_name: 'Another Category',
      resource_name: 'Job',
      resource_description: 'Grants the ability to read jobs',
      action: 'read',
      permissions: %i[read_job]
    )
  end

  let(:read_package_assignable) do
    instance_double(::Authz::PermissionGroups::Assignable,
      category_name: 'Category',
      resource_name: 'Package',
      resource_description: 'Grants the ability to read, uploaad, and delete packages',
      action: 'read',
      permissions: %i[download_package delete_package]
    )
  end

  let(:create_package_assignable) do
    instance_double(::Authz::PermissionGroups::Assignable,
      category_name: 'Category',
      resource_name: 'Package',
      resource_description: 'Grants the ability to read, uploaad, and delete packages',
      action: 'create',
      permissions: %i[upload_package]
    )
  end

  before do
    allow(::API::API).to receive(:endpoints).and_return([instance_double(Grape::Endpoint, routes: routes)])
    allow(::Authz::PermissionGroups::Assignable).to receive(:all).and_return({
      create_package: create_package_assignable,
      read_package: read_package_assignable,
      read_job: read_job_assignable
    })

    allow(task).to receive(:doc_path).and_return(doc_path)
  end

  describe '#check_docs' do
    subject(:check_docs) { task.check_docs }

    before do
      FileUtils.mkdir_p(path)
      task.compile_docs
    end

    context 'when the docs are up to date' do
      it 'outputs a success message' do
        expect { check_docs }
          .to output("Granular Personal Access Token allowed endpoints documentation is up to date.\n")
          .to_stdout
      end
    end

    context 'when the doc is updated manually' do
      before do
        File.write(doc_path, 'Manually adding this line at the end of the the doc', mode: 'a+')
      end

      let(:error_message) do
        <<~OUTPUT
          ##########
          #
          # Granular Personal Access Token allowed endpoints documentation is outdated! Please update it by running `bundle exec rake gitlab:permissions:routes:compile_docs`.
          #
          ##########
        OUTPUT
      end

      it 'raises an error' do
        expect { check_docs }.to raise_error(SystemExit).and output(error_message).to_stdout
      end
    end

    context 'when the doc is not up to date' do
      before do
        allow(::API::API).to receive(:endpoints).and_return([instance_double(Grape::Endpoint, routes: [])])
      end

      let(:error_message) do
        <<~OUTPUT
          ##########
          #
          # Granular Personal Access Token allowed endpoints documentation is outdated! Please update it by running `bundle exec rake gitlab:permissions:routes:compile_docs`.
          #
          ##########
        OUTPUT
      end

      it 'raises an error' do
        expect { described_class.new.check_docs }.to raise_error(SystemExit).and output(error_message).to_stdout
      end
    end
  end

  describe '#compile_docs' do
    subject(:compile_docs) { task.compile_docs }

    before do
      FileUtils.mkdir_p(path)
    end

    it 'outputs a success message' do
      expect { compile_docs }
        .to output("Granular Personal Access Token allowed endpoints documentation compiled.\n")
        .to_stdout
    end

    it 'creates granular_pat_rest_api_endpoints.md', :aggregate_failures do
      FileUtils.rm_f(doc_path)
      expect { File.read(doc_path) }.to raise_error(Errno::ENOENT)

      compile_docs

      expect(File.read(doc_path)).to match(/This documentation is auto-generated by a Rake task/)
    end
  end

  describe '#allowed_endpoints' do
    let(:expected_markdown) do
      <<~MARKDOWN.chomp
        ### Another Category resources

        #### Job

        Grants the ability to read jobs

        | Action | Access | Method | Path |
        | ------ | ------ | ------ | ---- |
        | Read | Project | `GET` | `/path/to/read_job_route` |

        ### Category resources

        #### Package

        Grants the ability to read, uploaad, and delete packages

        | Action | Access | Method | Path |
        | ------ | ------ | ------ | ---- |
        | Create | Group | `PUT` | `/path/to/upload_package_route` |
        |   | Instance | `PUT` | `/path/to/upload_package_route` |
        | Read | Project | `GET` | `/path/to/download_package_route` |
        |   |   | `DELETE` | `/path/to/delete_package_route` |
      MARKDOWN
    end

    # 1. Categories are sorted alphabetically
    # 2. Resources are sorted alphabetically
    # 3. Routes are sorted by
    #    1. Action, alphabetically
    #    1. Boundary (see `BOUNDARY_SORT_ORDER`)
    #    2. Request method (see `REQUEST_METHOD_SORT_ORDER`)
    # 4. Action and Access columns are blank when their values are equal to that
    #    of the previous row
    it 'returns the expected markdown' do
      expect(task.allowed_endpoints).to eq(expected_markdown)
    end
  end

  def create_route_double(permissions, boundary_type, request_method, path)
    instance_double(Grape::Router::Route,
      settings: {
        authorization: {
          permissions: permissions,
          boundary_type: boundary_type
        }
      },
      request_method: request_method,
      origin: path
    )
  end

  def read_job_route
    create_route_double(%i[read_job], :project, 'GET', '/api/:version/path/to/read_job_route')
  end

  def delete_package_route
    create_route_double(%i[delete_package], :project, 'DELETE', '/api/:version/path/to/delete_package_route')
  end

  def download_package_route
    create_route_double(%i[download_package], :project, 'GET', '/api/:version/path/to/download_package_route')
  end

  def upload_package_route
    instance_double(Grape::Router::Route,
      settings: {
        authorization: {
          permissions: %i[upload_package],
          boundaries: [{ boundary_type: :group }, { boundary_type: :instance }]
        }
      },
      request_method: 'PUT',
      origin: '/api/:version/path/to/upload_package_route'
    )
  end
end
